# -*- coding: utf-8 -*-
"""maps.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YFj8yW8wRBH_DPg6ib14y1TKBGZkXXwj
"""

#pip install utm

#import plotly
#print(plotly.__version__)

#pip install -U plotly

#import geopandas as gp
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
#import seaborn as sns
import utm
import folium
import json


import dash
import dash_core_components as dcc
import dash_html_components as html
import plotly.express as px

df1 = pd.read_csv("https://raw.githubusercontent.com/LarsBryld/socialdata/main/cph_traffic_2005-2009_original.csv",
                 parse_dates = ['Dato'],encoding='ISO-8859-1')
df2 = pd.read_csv("https://raw.githubusercontent.com/LarsBryld/socialdata/main/cph_traffic_2010-2014_original.csv",
                 parse_dates = ['Dato'],encoding='ISO-8859-1')

df = pd.concat((df1,df2))

# cleaning Vej-Id for more clear traffic directions
df['Vej-Id'] = df['Vej-Id'].str.split(n=4).str[-1]

#change the Hours headers
for i in range(7,31):
    df = df.rename(columns={df.columns[i]: df.columns[i].split('.')[1].split('-')[0]})
    df[df.columns[i]] = df[df.columns[i]].str.replace(',', '').fillna(0).astype('float')

### converting UTM coordinates into Latitute/Longitude using the "utm" library: https://pypi.org/project/utm/
# first we create a function that applies the utm api to 2 Series of data
def uf(x):
    return utm.to_latlon(x[0], x[1], 32, 'T')
# then we apply this function to the UTM coordinates in the file
#df['LatLon'] = df[['Easting','Northing']].apply(uf, axis=1)
df[['Lat', 'Lon']] = pd.DataFrame(df[['(UTM32)','(UTM32).1']].apply(uf, axis=1).tolist(), index=df.index)

# removing the unwanted columns
df = df.drop(columns = ['Unnamed: 0','Spor','(UTM32)','(UTM32).1'])

# converting hours data columns into rows
df = df.melt(id_vars=["Vej-Id","Vejnavn","Dato","Lat","Lon"],
        value_vars=['00','01','02','03','04','05','06','07','08','09','10','11','12',
                    '13', '14','15', '16','17', '18','19','20','21','22','23'],
        var_name="Hour", 
        value_name="Vehicles")

### moving rows data for Vehicles Entering the City, Leaving the City and Net Traffic Flows into columns
# Selecting only Entering Vehicles (and creating a unique index)
df_ent = df[df['Vej-Id'] == '-']
df_ent['index'] = df_ent['Vejnavn'] + df_ent['Dato'].dt.strftime('%Y-%m-%d') + df_ent['Hour']
df_ent = df_ent.set_index('index')
# Selecting only Leaving Vehicles (and creating a unique index)
df_ex = df[df['Vej-Id'] == '+']
df_ex['index'] = df_ex['Vejnavn'] + df_ex['Dato'].dt.strftime('%Y-%m-%d') + df_ex['Hour']
df_ex = df_ex.set_index('index')
# Selecting only Total Vehicles on the roads (and creating a unique index)
df = df[df['Vej-Id'] == 'T']
df['index'] = df['Vejnavn'] + df['Dato'].dt.strftime('%Y-%m-%d') + df['Hour']
df = df.set_index('index')
# adding columns for Vehicles Entering the City, Leaving and Net Traffic Flows
df['Entering Vehicles'] = df_ent['Vehicles']
df['Leaving Vehicles'] = df_ex['Vehicles']
df['Net Traffic Flow'] = df['Entering Vehicles'] - df['Leaving Vehicles']
# renaming the Total Vehicles column
df = df.rename(columns={"Vehicles": "Total Vehicles"})

# randomizing Latitude and longitude points
mu, sigma1 = 0, 0.0015
mu, sigma2 = 0, 0.003
noise1 = np.random.normal(mu, sigma1, [len(df),1])
noise2 = np.random.normal(mu, sigma2, [len(df),1]) 
df[['Lat_rand']] = df[['Lat']] + noise1
df[['Lon_rand']] = df[['Lon']] + noise2

# Add Day of the Week, Day, ,Week, Month, Year,
df["DayName"] = df['Dato'].apply(lambda x: x.day_name())
df["WeekDay"] = df['Dato'].dt.weekday
df["DayOfMonth"] = df['Dato'].dt.day
df["Week"] = df['Dato'].dt.week
df["Month"] = df['Dato'].dt.month
df["Year"] = df['Dato'].dt.year

# removing the 'Vej-Id' columns to avoid confusion (now all traffic data are in the columns for "-" , "+" and "T")
df = df.drop(columns = ['Vej-Id'])


df_base = df

# first we upload CPH districts polygons from GeoJson file
import urllib.request, json 

with urllib.request.urlopen("https://raw.githubusercontent.com/LarsBryld/socialdata/main/copenhagen_districts.geojson") as url:
    cph_districts = json.loads(url.read().decode())

# we extract the districts names from the GeoJson file
districts = []
for i in range(len(cph_districts["features"])):
    districts.append(cph_districts["features"][i]['properties']['name'])
    
#districts

# then we create a unique list of CPH roads, with corresponding Longitude and Latitute
dfu = pd.concat((pd.DataFrame(df['Vejnavn'].unique(),columns=['Vejnavn']),
           pd.DataFrame(df['Lon'].unique(),columns=['Lon']),
           pd.DataFrame(df['Lat'].unique(),columns=['Lat'])), axis=1)
#dfu

# finally we find in what district each road falls, using the code from this example:
# https://stackoverflow.com/questions/57727739/how-to-determine-if-a-point-is-inside-a-polygon-using-geojson-and-shapely

from shapely.geometry import shape, GeometryCollection, Point

dist = []

for i in range(len(dfu)):
    for j in range(len(districts)):
        if shape(cph_districts["features"][j]['geometry']).contains(Point(dfu['Lon'][i],dfu['Lat'][i])):
            dist.append(cph_districts["features"][j]['properties']['name'])


# In[ ]:


# then we add the district name to our list of unique roads
dfu = pd.concat((dfu, pd.DataFrame(dist,columns=['District'])), axis=1)
#dfu

# adding the District info to the original DF
df = pd.merge(df, dfu[['Vejnavn','District']], on="Vejnavn")

#df

# grouping traffic data by Year and District
dfc = df.groupby(["Year", "District"]).mean()["Total Vehicles"].unstack()
dfc = dfc.reset_index()
#dfc

# for the Plotly Choropleth to work we nee to put all columns into rows 

dfc = dfc.melt(id_vars=['Year'],
        value_vars=dfc.columns.values[1:],
        var_name="District", 
        value_name="Total Vehicles")

# creating an interactive map for CPH traffic
import plotly.express as px

max_value = dfc['Total Vehicles'].max()
fig = px.choropleth(dfc, locations='District',
                    geojson=cph_districts, featureidkey="properties.name",
                           color='Total Vehicles',
                           color_continuous_scale="Viridis",
                           range_color=(0, max_value),
                           projection="mercator",
                    animation_frame="Year", animation_group="District"
                          )

fig.update_geos(fitbounds="locations", visible=False)
fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
fig.show()

# grouping traffic data by Hour and District
dfh = df.groupby(["Hour", "District"]).mean()["Total Vehicles"].unstack()
dfh = dfh.reset_index()
#dfh

# for the Plotly Choropleth to work we nee to put all columns into rows 

dfh = dfh.melt(id_vars=['Hour'],
        value_vars=dfh.columns.values[1:],
        var_name="District", 
        value_name="Total Vehicles")
#dfh

# creating an interactive map for CPH traffic
import plotly.express as px

max_value = dfh['Total Vehicles'].max()
min_value = dfh['Total Vehicles'].min()
fig = px.choropleth(dfh, locations='District',
                    geojson=cph_districts, featureidkey="properties.name",
                           color='Total Vehicles',
                           color_continuous_scale="Viridis",
                           range_color=(min_value, max_value),
                           projection="mercator",
                    animation_frame="Hour", animation_group="District"
                          )

fig.update_geos(fitbounds="locations", visible=False)
fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
fig.show()

#pip list